import{r as x,_ as D}from"./mainweb-D3o3LwRH.js";import{t as n,b as Ne,p as Ee,r as Pe}from"./httpService-BfYSniVs.js";window.activeRequests={};window.counts={};window.requests={};window.requestCache={};window.firstTimeRequests={};window.localRequestCache={};window.noGetRequests={};try{let s=sessionStorage.getItem("requestCache"),I=JSON.parse(s);I&&(requestCache=I)}catch{}var Oe=window.location.href;sessionStorage.getItem("currenturl")==Oe&&(sessionStorage.removeItem("requestCache"),requestCache={});sessionStorage.setItem("currenturl",Oe);const ve=(...s)=>{let I=!1;return s.forEach(j=>{(j=="fetching"||j=="started"||j=="waiting")&&(I=!0)}),I},Ge=(s,{mandatoryValues:I,mandatoryParams:j,select:k,filter:U,sort:N,offset:J,limit:Z,noGet:_,doCache:$,deleteUrl:Be,updateUrl:xe})=>{var de,ne,ce,ue,oe,le,fe,he,ge,qe;counts[s]||(counts[s]=0);let[f,ee]=x.useState(U??{});n("filters",f);let[o,te]=x.useState(N??{sortColumn:"id",sortOrder:"ASC"}),[g,V]=x.useState(J??0),[y,ae]=x.useState(Z??1e3);$&&(f.isCache=!0);let[b,X]=x.useState(counts[s]),[O,B]=x.useState("fetching"),[v,G]=x.useState(""),[t,E]=x.useState(null),a=T(s,k,f,o,g,y);n("🔯 useBackend for "+a);const c=(e,r,u)=>{r==ee&&n("useBackend for "+a+" trying to setting filters with "+JSON.stringify(u)),Object.keys(activeRequests).length===0?(r==E&&n("useBackend for "+a+" trying to set response",u),r==E&&n("useBackend for "+a+" setting response with ",u),r(u),e=u):(r!=E&&(e=u),r==E&&n("useBackend for "+a+" waiting to set response with ",u),setTimeout(()=>{c(e,r,u)},1e3))},P=async e=>{var S,l,m,R,A,K,M,W,z,H,Q;let r=typeof e<"u";if(n("mandatoryParams",j),j){let h=[];if(j.forEach(L=>{f[L]||h.push(L)}),h.length){n("useBackend for "+a+" missing params "+h.join(", "));return}}v!=""&&c(v,G,"");try{if(requests[a]="",firstTimeRequests[a]=!0,activeRequests[a]&&!r){n("useBackend for "+a+" waiting in "+window.location.href);return}activeRequests[a]=!0}catch{delete activeRequests[a]}n("🌐 useBackend calling api "+a+" with filters "+JSON.stringify(f));let u={};e&&(u={takeNew:!0,requestDate:new Date().toISOString()}),noGetRequests[a]=!1;let i={};try{i=await Ne(""+s,k,{...f,...u},o,g,y),n("🌐 useBackend for "+a+" got response ",i);try{if(a){let h=JSON.stringify(i.data);requests[a]&&console.error({repeatedCalls:{key:a,res:h}}),requests[a]=h}}catch{n("error in setting request")}if(!(((S=i.data)==null?void 0:S.Results)instanceof Array)&&typeof((l=i.data)==null?void 0:l.Results)=="object"?i.data.data=[(m=i.data)==null?void 0:m.Results]:i.data.data=((R=i.data)==null?void 0:R.Results)&&((K=(A=i.data)==null?void 0:A.Results)==null?void 0:K.map)&&((W=(M=i.data)==null?void 0:M.Results)==null?void 0:W.map((h,L)=>({...h,index:L+1}))),(z=i.data)!=null&&z.error)alert(i.data.error),D.error(i.data.message+", please reload or try again"),c(v,G,i.data.message);else{try{localRequestCache[a]=i.data,n("useBackend for "+a+" setting local cache with ",localRequestCache[a]),$&&((H=i.data.data)!=null&&H.length)&&(requestCache[a]=i.data,sessionStorage.setItem("requestCache",JSON.stringify(requestCache)))}catch{delete requestCache[a],delete localRequestCache[a],n("requestCache not working"),i={data:{data:[]}}}delete activeRequests[a],c(t,E,{data:{...i.data}})}}catch(h){D.error(h.message+", please reload or try again"),c(v,G,h.message),delete requestCache[a],delete localRequestCache[a],i={data:{data:[]}}}return delete activeRequests[a],B("finished"),counts[s]=counts[s]+1,c(b,X,counts[s]),[(Q=i.data)==null?void 0:Q.data]};let p=!1,F="";try{$&&(n("useBackend for "+a+" localRequestCache",localRequestCache[a]),requestCache[a]&&(F=a,p=!0))}catch{n("requestCache not working")}if(a&&_&&noGetRequests[a]==null&&(noGetRequests[a]=!0),!s)throw new Error("url is required");let se=!1;p&&((ne=(de=t==null?void 0:t.data)==null?void 0:de.data)!=null&&ne.length||(n("requestCache",requestCache),t={data:{data:requestCache[F].data}},O="finished",counts[s]=counts[s]+1,b=counts[s],n("useBackend for "+a+" got data from cache"),se=!0));let ie=!_;(noGetRequests[a]==null||noGetRequests[a]==!1)&&(ie=!0);let re=!1;if(ie&&!se){n("localRequestCache",localRequestCache);let e=s+JSON.stringify({select:k,filters:f,localSort:o,localOffset:g,localLimit:y});firstTimeRequests[e]?activeRequests[e]?n("waiting for "+e+" in "+window.location.href):localRequestCache[e]&&(t={data:{data:localRequestCache[e].data}},O="finished",counts[s]=counts[s]+1,b=counts[s],n("useBackend for "+e+" getting data from local cache",t)):(re=!0,P(),n("useBackend for "+e+" getting data for the first time"))}else n("useBackend for "+a+" not calling api as noGet is true or cache is restored");x.useEffect(()=>{if(!re){let e=20,r=setInterval(()=>{localRequestCache[a]&&(clearInterval(r),B("finished")),activeRequests[a]||(clearInterval(r),B("finished")),e--,e<=0&&(clearInterval(r),B("finished"))},1e3)}},[]);let C={rows:null,row:null};return((ue=(ce=t==null?void 0:t.data)==null?void 0:ce.data)!=null&&ue.length||O=="finished")&&((le=(oe=t==null?void 0:t.data)==null?void 0:oe.data)!=null&&le.length?(C.rows=(fe=t.data)==null?void 0:fe.data,(ge=(he=t==null?void 0:t.data)==null?void 0:he.data)!=null&&ge.length&&(C.row=(qe=t.data)==null?void 0:qe.data[0])):C.rows=[]),C.setFilter=async e=>{J=0;let r=!1;return typeof e=="boolean"?(e={},r=!0):e&&Object.keys(e).length&&(r=!0),c(g,V,0),f={...f,...e},c(f,ee,{...f,...U}),a=T(s,k,f,o,g,y),n("useBackend for "+a+" setting filter with "+JSON.stringify(e)),await P(r)},C.setSort=async e=>(N={...N,...e},c(o,te,{...N,...e}),n("useBackend for "+a+" setting sort with "+JSON.stringify(e)),a=T(s,k,f,o,g,y),await P(!0)),C.setLimit=async e=>(Z=e,J=0,c(y,ae,e),c(g,V,0),n("useBackend for "+a+" setting limit with "+e),a=T(s,k,f,o,g,y),await P(!0)),C.setOffset=async e=>(J=e,c(g,V,e),n("useBackend for "+a+" setting offset with "+e),a=T(s,k,f,o,g,y),await P(!0)),C.setOffsetAndLimit=async(e,r,u,i)=>(J=e,Z=r,N={sortColumn:u,sortOrder:i},y=r,g=e,o=N,c(g,V,e),c(y,ae,r),c(o,te,{sortColumn:u,sortOrder:i}),n("useBackend for "+a+" setting offset with "+e+" and limit with "+r),a=T(s,k,f,o,g,y),await P(!0)),C.setWholeData=e=>{E({...t,rows:{...t.data,rows:e}})},C.updateLocal=e=>{var u,i,S,l,m;let r=(i=(u=t==null?void 0:t.data)==null?void 0:u.data)==null?void 0:i.findIndex(R=>R.id===e.id);if(r>=0&&(e={...t.data.data[r],...e}),(S=t==null?void 0:t.data)!=null&&S.data||(t={data:{data:[]}}),r>=0)t.data.data[r]=e;else{let R=(m=(l=t==null?void 0:t.data)==null?void 0:l.data)!=null&&m.length?t.data.data.length:0;(o==null?void 0:o.sortOrder)=="DESC"?(e.index=1,t.data.data=[e,...t.data.data.map((A,K)=>({...A,index:K+2}))]):(e.index=R+1,t.data.data=[...t.data.data,e])}E({...t}),counts[s]=counts[s]+1,c(b,X,counts[s])},C.update=async(e,r,u,i)=>{var l,m,R,A,K,M,W,z,H,Q,h,L,we,ye,Ce,me,Re,ke,Se,je;let S={...e};delete S.index;try{let d=await Ee(xe||s,S);if(i&&i("It's Saved"),(l=d.data)!=null&&l.Results){if(((R=(m=d==null?void 0:d.data)==null?void 0:m.Results)==null?void 0:R.IsSuccess)==!1&&((K=(A=d==null?void 0:d.data)==null?void 0:A.Results)!=null&&K.Message))return D.error((W=(M=d==null?void 0:d.data)==null?void 0:M.Results)==null?void 0:W.Message),Promise.reject({message:(H=(z=d==null?void 0:d.data)==null?void 0:z.Results)==null?void 0:H.Message});if(p){let q=F.split("{")[0];Object.keys(requestCache).forEach(w=>{w.startsWith(q)&&delete requestCache[w]}),sessionStorage.setItem("requestCache",JSON.stringify(requestCache))}if(((Q=d.data)==null?void 0:Q.Results)instanceof Array&&typeof((h=d.data)==null?void 0:h.Results)=="object"){let q=(we=(L=t==null?void 0:t.data)==null?void 0:L.data)==null?void 0:we.findIndex(w=>w.id===d.data.data.id);if(e.id=d.data.data.id,q>=0&&(e={...t.data.data[q],...e}),(ye=t==null?void 0:t.data)!=null&&ye.Results||(t={data:{data:[]}}),!r){if(q>=0)t.data.data[q]=e;else{let w=(me=(Ce=t==null?void 0:t.data)==null?void 0:Ce.data)!=null&&me.length?t.data.data.length:0;(o==null?void 0:o.sortOrder)=="DESC"?(e.index=1,t.data.data=[e,...t.data.data.map((Y,Ie)=>({...Y,index:Ie+2}))]):(e.index=w+1,t.data.data=[...t.data.data,e])}E({...t}),c(O,B,"finished"),counts[s]=counts[s]+1,c(b,X,counts[s])}}else u=!0,c(O,B,"finished"),counts[s]=counts[s]+1,c(b,X,counts[s]);return u&&(i&&i("Refreshing"),c(O,B,"refreshing"),a=T(s,k,f,o,g,y),await P(!0)),[e,t.data.data,d.data]}else{c(O,B,"finished");let q=(Re=t==null?void 0:t.data)==null?void 0:Re.SecurityValidations;if(q)return c(v,G,q.join(`
`)),Promise.reject({message:q.join(`
`)});if((ke=d==null?void 0:d.data)!=null&&ke.modelState){let w=[];return(Se=d==null?void 0:d.data)==null||Se.modelState.forEach(Y=>{w.push(Y.Key+": "+Y.Value)}),c(v,G,w.join.join(`
`)),Promise.reject({message:w.join(`
`)})}else return Promise.reject({message:d.data.message})}}catch(d){let q=d.response,w=(je=q==null?void 0:q.data)==null?void 0:je.SecurityValidations;return w?(c(d,G,w.join(`
`)),Promise.reject({message:w.join(`
`)})):Promise.reject(d)}},C.delete=async(e,r)=>{var i,S;let u={...e};try{let l=await Pe(Be||s,u);if(l.data.Results)return await P(!0),[e,t.data.data,l];if(c(O,B,"finished"),(i=l==null?void 0:l.data)!=null&&i.modelState){let m=[];return(S=l==null?void 0:l.data)==null||S.modelState.forEach(R=>{m.push(R.Key+": "+R.Value)}),c(v,G,m.join.join(`
`)),Promise.reject({message:m.join(`
`)})}else return Promise.reject({message:"Something went wrong"})}catch(l){return Promise.reject(l)}},{...C,status:O,counter:b,localSort:o,localOffset:g,localLimit:y,filters:f}};function T(s,I,j,k,U,N){try{return s+JSON.stringify({select:I,filters:j,localSort:k,localOffset:U,localLimit:N})}catch{n("error in key generation")}return s}export{ve as i,Ge as u};
