import{r as I,_ as D}from"./mainweb--9jikUVK.js";import{t as d,a as Je,p as Pe,r as ve}from"./httpService-BGS5IZ2K.js";window.activeRequests={};window.counts={};window.requests={};window.requestCache={};window.firstTimeRequests={};window.localRequestCache={};window.noGetRequests={};try{let s=sessionStorage.getItem("requestCache"),x=JSON.parse(s);x&&(requestCache=x)}catch{}var Be=window.location.href;sessionStorage.getItem("currenturl")==Be&&(sessionStorage.removeItem("requestCache"),requestCache={});sessionStorage.setItem("currenturl",Be);const be=(...s)=>{let x=!1;return s.forEach(O=>{(O=="fetching"||O=="started"||O=="waiting")&&(x=!0)}),x};let Oe=0;const pe=(s,{mandatoryValues:x,mandatoryParams:O,select:k,filter:Q,sort:N,offset:v,limit:Z,noGet:_,doCache:$,deleteUrl:Ie,updateUrl:xe})=>{var ne,de,ce,oe,ue,le,fe,he,ge,qe;Oe++,counts[s]||(counts[s]=0);let[f,ee]=I.useState(Q??{});d("filters",f);let[u,te]=I.useState(N??{sortColumn:"id",sortOrder:"ASC"}),[g,U]=I.useState(v??0),[y,ae]=I.useState(Z??1e3);$&&(f.isCache=!0);let[E,X]=I.useState(counts[s]),[j,B]=I.useState("fetching"),[G,b]=I.useState(""),[t,J]=I.useState(null),a=L(s,k,f,u,g,y);d("🔯 useBackend for "+a);const c=(e,r,o)=>{r==ee&&d("useBackend for "+a+" trying to setting filters with "+JSON.stringify(o)),Object.keys(activeRequests).length===0?(r==J&&d("useBackend for "+a+" trying to set response",o),r==J&&d("useBackend for "+a+" setting response with ",o),console.log("updating state with value "+JSON.stringify(o)+" for "+s+" in "+window.location.href),r(o),e=o):(r!=J&&(e=o),r==J&&d("useBackend for "+a+" waiting to set response with ",o),console.log("updating state with value "+JSON.stringify(o)+" for "+s+" in "+window.location.href),setTimeout(()=>{c(e,r,o)},1e3))},P=async e=>{var S,l,m,R,p,A,T,M,W,z,H;console.log("useBackend for "+a+" fetching data with uniqueId "+Oe);let r=typeof e<"u";if(d("mandatoryParams",O),O){let h=[];if(O.forEach(K=>{f[K]||h.push(K)}),h.length){d("useBackend for "+a+" missing params "+h.join(", "));return}}G!=""&&c(G,b,"");try{if(requests[a]="",firstTimeRequests[a]=!0,activeRequests[a]&&!r){d("useBackend for "+a+" waiting in "+window.location.href);return}activeRequests[a]=!0}catch{delete activeRequests[a]}d("🌐 useBackend calling api "+a+" with filters "+JSON.stringify(f));let o={};e&&(o={takeNew:!0,requestDate:new Date().toISOString()}),noGetRequests[a]=!1;let i={};try{i=await Je(""+s,k,{...f,...o},u,g,y),d("🌐 useBackend for "+a+" got response ",i);try{if(a){let h=JSON.stringify(i.data);requests[a]&&console.error({repeatedCalls:{key:a,res:h}}),requests[a]=h}}catch{d("error in setting request")}if(!(((S=i.data)==null?void 0:S.Results)instanceof Array)&&typeof((l=i.data)==null?void 0:l.Results)=="object"?i.data.data=[(m=i.data)==null?void 0:m.Results]:i.data.data=((R=i.data)==null?void 0:R.Results)&&((A=(p=i.data)==null?void 0:p.Results)==null?void 0:A.map)&&((M=(T=i.data)==null?void 0:T.Results)==null?void 0:M.map((h,K)=>({...h,index:K+1}))),(W=i.data)!=null&&W.error)alert(i.data.error),D.error(i.data.message+", please reload or try again"),c(G,b,i.data.message);else{try{localRequestCache[a]=i.data,d("useBackend for "+a+" setting local cache with ",localRequestCache[a]),$&&((z=i.data.data)!=null&&z.length)&&(requestCache[a]=i.data,sessionStorage.setItem("requestCache",JSON.stringify(requestCache)))}catch{delete requestCache[a],delete localRequestCache[a],d("requestCache not working"),i={data:{data:[]}}}delete activeRequests[a],c(t,J,{data:{...i.data}}),console.log("updated response",t)}}catch(h){D.error(h.message+", please reload or try again"),c(G,b,h.message),delete requestCache[a],delete localRequestCache[a],i={data:{data:[]}}}return delete activeRequests[a],B("finished"),console.log("updated status",j),counts[s]=counts[s]+1,c(E,X,counts[s]),[(H=i.data)==null?void 0:H.data]};let V=!1,F="";try{$&&(d("useBackend for "+a+" localRequestCache",localRequestCache[a]),requestCache[a]&&(F=a,V=!0))}catch{d("requestCache not working")}if(a&&_&&noGetRequests[a]==null&&(noGetRequests[a]=!0),!s)throw new Error("url is required");let se=!1;V&&((de=(ne=t==null?void 0:t.data)==null?void 0:ne.data)!=null&&de.length||(d("requestCache",requestCache),t={data:{data:requestCache[F].data}},j="finished",counts[s]=counts[s]+1,E=counts[s],d("useBackend for "+a+" got data from cache"),se=!0));let ie=!_;(noGetRequests[a]==null||noGetRequests[a]==!1)&&(ie=!0);let re=!1;if(ie&&!se){d("localRequestCache",localRequestCache);let e=s+JSON.stringify({select:k,filters:f,localSort:u,localOffset:g,localLimit:y});console.log("useBackend for "+e+" localRequestCache",localRequestCache[e]),s.includes("/CoordinatorJson/GetParticipants?ParticipantType=2&TeamId=")&&console.log({first:firstTimeRequests[e],active:activeRequests[e],local:localRequestCache[e],noGet:noGetRequests[e]}),firstTimeRequests[e]?activeRequests[e]?d("waiting for "+e+" in "+window.location.href):localRequestCache[e]&&(t={data:{data:localRequestCache[e].data}},j="finished",counts[s]=counts[s]+1,E=counts[s],d("useBackend for "+e+" getting data from local cache",t)):(re=!0,P(),d("useBackend for "+e+" getting data for the first time"))}else d("useBackend for "+a+" not calling api as noGet is true or cache is restored");I.useEffect(()=>{if(!re){let e=20,r=setInterval(()=>{localRequestCache[a]&&(clearInterval(r),B("finished")),activeRequests[a]||(clearInterval(r),B("finished")),e--,e<=0&&(clearInterval(r),B("finished"))},1e3)}},[]);let C={rows:null,row:null};return((oe=(ce=t==null?void 0:t.data)==null?void 0:ce.data)!=null&&oe.length||j=="finished")&&((le=(ue=t==null?void 0:t.data)==null?void 0:ue.data)!=null&&le.length?(C.rows=(fe=t.data)==null?void 0:fe.data,(ge=(he=t==null?void 0:t.data)==null?void 0:he.data)!=null&&ge.length&&(C.row=(qe=t.data)==null?void 0:qe.data[0])):C.rows=[]),C.setFilter=async e=>{v=0;let r=!1;return typeof e=="boolean"?(e={},r=!0):e&&Object.keys(e).length&&(r=!0),c(g,U,0),f={...f,...e},c(f,ee,{...f,...Q}),a=L(s,k,f,u,g,y),d("useBackend for "+a+" setting filter with "+JSON.stringify(e)),await P(r)},C.setSort=async e=>(N={...N,...e},c(u,te,{...N,...e}),d("useBackend for "+a+" setting sort with "+JSON.stringify(e)),a=L(s,k,f,u,g,y),await P(!0)),C.setLimit=async e=>(Z=e,v=0,c(y,ae,e),c(g,U,0),d("useBackend for "+a+" setting limit with "+e),a=L(s,k,f,u,g,y),await P(!0)),C.setOffset=async e=>(v=e,c(g,U,e),d("useBackend for "+a+" setting offset with "+e),a=L(s,k,f,u,g,y),await P(!0)),C.setOffsetAndLimit=async(e,r,o,i)=>(v=e,Z=r,N={sortColumn:o,sortOrder:i},y=r,g=e,u=N,c(g,U,e),c(y,ae,r),c(u,te,{sortColumn:o,sortOrder:i}),d("useBackend for "+a+" setting offset with "+e+" and limit with "+r),a=L(s,k,f,u,g,y),await P(!0)),C.setWholeData=e=>{J({...t,rows:{...t.data,rows:e}})},C.updateLocal=e=>{var o,i,S,l,m;let r=(i=(o=t==null?void 0:t.data)==null?void 0:o.data)==null?void 0:i.findIndex(R=>R.id===e.id);if(r>=0&&(e={...t.data.data[r],...e}),(S=t==null?void 0:t.data)!=null&&S.data||(t={data:{data:[]}}),r>=0)t.data.data[r]=e;else{let R=(m=(l=t==null?void 0:t.data)==null?void 0:l.data)!=null&&m.length?t.data.data.length:0;(u==null?void 0:u.sortOrder)=="DESC"?(e.index=1,t.data.data=[e,...t.data.data.map((p,A)=>({...p,index:A+2}))]):(e.index=R+1,t.data.data=[...t.data.data,e])}J({...t}),counts[s]=counts[s]+1,c(E,X,counts[s])},C.update=async(e,r,o,i)=>{var l,m,R,p,A,T,M,W,z,H,h,K,we,ye,Ce,me,Re,ke,Se,je;let S={...e};delete S.index;try{let n=await Pe(xe||s,S);if(i&&i("It's Saved"),(l=n.data)!=null&&l.Results){if(((R=(m=n==null?void 0:n.data)==null?void 0:m.Results)==null?void 0:R.IsSuccess)==!1&&((A=(p=n==null?void 0:n.data)==null?void 0:p.Results)!=null&&A.Message))return D.error((M=(T=n==null?void 0:n.data)==null?void 0:T.Results)==null?void 0:M.Message),Promise.reject({message:(z=(W=n==null?void 0:n.data)==null?void 0:W.Results)==null?void 0:z.Message});if(V){let q=F.split("{")[0];Object.keys(requestCache).forEach(w=>{w.startsWith(q)&&delete requestCache[w]}),sessionStorage.setItem("requestCache",JSON.stringify(requestCache))}if(((H=n.data)==null?void 0:H.Results)instanceof Array&&typeof((h=n.data)==null?void 0:h.Results)=="object"){let q=(we=(K=t==null?void 0:t.data)==null?void 0:K.data)==null?void 0:we.findIndex(w=>w.id===n.data.data.id);if(e.id=n.data.data.id,q>=0&&(e={...t.data.data[q],...e}),(ye=t==null?void 0:t.data)!=null&&ye.Results||(t={data:{data:[]}}),!r){if(q>=0)t.data.data[q]=e;else{let w=(me=(Ce=t==null?void 0:t.data)==null?void 0:Ce.data)!=null&&me.length?t.data.data.length:0;(u==null?void 0:u.sortOrder)=="DESC"?(e.index=1,t.data.data=[e,...t.data.data.map((Y,Ne)=>({...Y,index:Ne+2}))]):(e.index=w+1,t.data.data=[...t.data.data,e])}J({...t}),c(j,B,"finished"),counts[s]=counts[s]+1,c(E,X,counts[s])}}else o=!0,c(j,B,"finished"),counts[s]=counts[s]+1,c(E,X,counts[s]);return o&&(i&&i("Refreshing"),c(j,B,"refreshing"),a=L(s,k,f,u,g,y),await P(!0)),[e,t.data.data,n.data]}else{c(j,B,"finished");let q=(Re=t==null?void 0:t.data)==null?void 0:Re.SecurityValidations;if(q)return c(G,b,q.join(`
`)),Promise.reject({message:q.join(`
`)});if((ke=n==null?void 0:n.data)!=null&&ke.modelState){let w=[];return(Se=n==null?void 0:n.data)==null||Se.modelState.forEach(Y=>{w.push(Y.Key+": "+Y.Value)}),c(G,b,w.join.join(`
`)),Promise.reject({message:w.join(`
`)})}else return Promise.reject({message:n.data.message})}}catch(n){let q=n.response,w=(je=q==null?void 0:q.data)==null?void 0:je.SecurityValidations;return w?(c(n,b,w.join(`
`)),Promise.reject({message:w.join(`
`)})):Promise.reject(n)}},C.delete=async(e,r)=>{var i,S;let o={...e};try{let l=await ve(Ie||s,o);if(l.data.Results)return await P(!0),[e,t.data.data,l];if(c(j,B,"finished"),(i=l==null?void 0:l.data)!=null&&i.modelState){let m=[];return(S=l==null?void 0:l.data)==null||S.modelState.forEach(R=>{m.push(R.Key+": "+R.Value)}),c(G,b,m.join.join(`
`)),Promise.reject({message:m.join(`
`)})}else return Promise.reject({message:"Something went wrong"})}catch(l){return Promise.reject(l)}},{...C,status:j,counter:E,localSort:u,localOffset:g,localLimit:y,filters:f}};function L(s,x,O,k,Q,N){try{return s+JSON.stringify({select:x,filters:O,localSort:k,localOffset:Q,localLimit:N})}catch{d("error in key generation")}return s}export{be as i,pe as u};
